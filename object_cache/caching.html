<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
      <title>GraphQL Enterprise - Object Cache - Caching Results</title>
    
    <link href="https://fonts.googleapis.com/css?family=Rubik:300,400,700" rel="stylesheet" />
    <link rel="stylesheet" href="/css/main.css">
    <link rel="icon" href="/graphql-ruby-icon.png">
  </head>
  <body>
    <div class="header">
      <div class="header-container">
        <div class="nav">
          <a href="/" class="img-link">
            <img src="/graphql-ruby.png" alt="GraphQL Ruby Logo" />
          </a>
          <a href="/getting_started">Get Started</a>
          <a href="/guides">Guides</a>
          <a href="/api-doc/2.0.22/">API</a>
          <a href="https://tinyletter.com/graphql-ruby">Newsletter</a>
          <a href="https://github.com/rmosolgo/graphql-ruby">Source Code</a>
          <a href="https://graphql.pro">Upgrade to Pro</a>
          <input
            class="search-input"
            onkeyup="GraphQLRubySearch.run(this)"
            type="text"
            placeholder="Search the docs..."
          />
        </div>
      </div>
      <div class="search-results-container">
        <div id="search-results">
        </div>
      </div>
    </div>
    <div class="container">
      <ul class="breadcrumb">
  <li><a href="/guides">Guides</a></li>
  <li>
    <select class="jump-to-select" onchange="navigateToSelected(this)">
      
        <option  data-target="/schema/definition.html">Schema</option>
      
        <option  data-target="/queries/executing_queries.html">Queries</option>
      
        <option  data-target="/type_definitions/objects.html">Type Definitions</option>
      
        <option  data-target="/authorization/overview.html">Authorization</option>
      
        <option  data-target="/fields/introduction.html">Fields</option>
      
        <option  data-target="/mutations/mutation_root.html">Mutations</option>
      
        <option  data-target="/errors/overview.html">Errors</option>
      
        <option  data-target="/pagination/overview.html">Pagination</option>
      
        <option  data-target="/relay/range_add.html">Relay</option>
      
        <option  data-target="/dataloader/overview.html">Dataloader</option>
      
        <option  data-target="/subscriptions/overview.html">Subscriptions</option>
      
        <option  data-target="/pro/home.html">GraphQL Pro</option>
      
        <option  data-target="/operation_store/overview.html">GraphQL Pro - OperationStore</option>
      
        <option  data-target="/defer/overview.html">GraphQL Pro - Defer</option>
      
        <option  data-target="/limiters/overview.html">GraphQL Enterprise - Rate Limiters</option>
      
        <option  selected data-target="/object_cache/overview.html">GraphQL Enterprise - Object Cache</option>
      
        <option  data-target="/changesets/overview.html">GraphQL Enterprise - Changesets</option>
      
        <option  data-target="/javascript_client/overview.html">JavaScript Client</option>
      
        <option  data-target="/language_tools/visitor.html">Language Tools</option>
      
        <option  data-target="/testing/overview.html">Testing</option>
      
        <option  data-target="/development.html">Other</option>
      
    </select>
  </li>
  <li>
    <select class="jump-to-select" onchange="navigateToSelected(this)">
      
        <option  data-target="/object_cache/overview.html">GraphQL ObjectCache</option>
      
        <option  data-target="/object_cache/schema_setup.html">Schema Setup</option>
      
        <option  selected data-target="/object_cache/caching.html">Caching Results</option>
      
        <option  data-target="/object_cache/redis.html">Redis Configuration</option>
      
        <option  data-target="/object_cache/runtime_considerations.html">Runtime Considerations</option>
      
    </select>
  </li>
</ul>



  <div class="enterprise-header">
    <p>
      <strong>🌟 Enterprise Feature 🌟</strong>
      <span style="font-style: italic;">
        This feature is bundled with <a href="https://graphql.pro/enterprise">GraphQL-Enterprise</a>.
      </span>
    </p>
  </div>

<h1 class="guide-header">Caching Results</h1>
<div class="guide-table-of-contents"><div class="table-of-contents">
  <h3 class="contents-header">Contents</h3>
  <ol class='contents-list'><li class='contents-entry'><a href='#cacheable-true-false'><code>cacheable(true|false)</code>
</a></li><li class='contents-entry'><a href='#public'><code>public:</code>
</a></li><li class='contents-entry'><a href='#ttl'><code>ttl:</code>
</a></li><li class='contents-entry'><a href='#caching-lists-and-connections'>Caching lists and connections
</a></li><li class='contents-entry'><a href='#caching-introspection'>Caching Introspection
</a></li><li class='contents-entry'><a href='#object-dependencies'>Object Dependencies
</a></li></ol>
</div>
</div>
<div class="guide-container">
  <p><code class="language-plaintext highlighter-rouge">GraphQL::Enterprise::ObjectCache</code> supports several different caching configurations for objects and fields. To get started, include the extension in your base object class and base field class and use <code class="language-plaintext highlighter-rouge">cacheable(...)</code> to set up the default cache behavior:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/graphql/types/base_object.rb</span>
<span class="k">class</span> <span class="nc">Types::BaseObject</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="o">::</span><span class="no">Object</span>
  <span class="kp">include</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Enterprise</span><span class="o">::</span><span class="no">ObjectCache</span><span class="o">::</span><span class="no">ObjectIntegration</span>
  <span class="n">field_class</span> <span class="no">Types</span><span class="o">::</span><span class="no">BaseField</span>
  <span class="n">cacheable</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1"># see below</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/graphql/types/base_field.rb</span>
<span class="k">class</span> <span class="nc">Types::BaseField</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="o">::</span><span class="no">Field</span>
  <span class="kp">include</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Enterprise</span><span class="o">::</span><span class="no">ObjectCache</span><span class="o">::</span><span class="no">FieldIntegration</span>
  <span class="n">cacheable</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1"># see below</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Also, make sure your base interface module is using your field class:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/graphql/types/base_interface.md</span>
<span class="k">module</span> <span class="nn">Types::BaseInterface</span>
 <span class="n">field_class</span> <span class="no">Types</span><span class="o">::</span><span class="no">BaseField</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Field caching can be configured per-field, too, for example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:latest_update</span><span class="p">,</span> <span class="no">Types</span><span class="o">::</span><span class="no">Update</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span><span class="p">,</span> <span class="ss">cacheable: </span><span class="p">{</span> <span class="ss">ttl: </span><span class="mi">60</span> <span class="p">}</span>

<span class="n">field</span> <span class="ss">:random_number</span><span class="p">,</span> <span class="no">Int</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span><span class="p">,</span> <span class="ss">cacheable: </span><span class="kp">false</span>
</code></pre></div></div>

<p>Only <em>queries</em> are cached. <code class="language-plaintext highlighter-rouge">ObjectCache</code> skips mutations and subscriptions altogether.</p>

<h2 id="cacheabletruefalse"><code class="language-plaintext highlighter-rouge">cacheable(true|false)</code></h2>

<p><code class="language-plaintext highlighter-rouge">cacheable(true)</code> means that the configured type or field may be stored in the cache until its cache fingerprint changes. It also defaults to <code class="language-plaintext highlighter-rouge">public: false</code>, meaning that clients will <em>not</em> share cached responses. See <a href="#public"><code class="language-plaintext highlighter-rouge">public:</code></a> below for more about this option.</p>

<p><code class="language-plaintext highlighter-rouge">cacheable(false)</code> disables caching for the configured type or field. Any query that includes this type or field will neither check for an already-cached value nor update the cache with its result.</p>

<h2 id="public"><code class="language-plaintext highlighter-rouge">public:</code></h2>

<p><code class="language-plaintext highlighter-rouge">cacheable(public: false)</code> means that a type or field may be <em>cached</em>, but <a href="/object_cache/schema_setup#context-fingerprint"><code class="language-plaintext highlighter-rouge">Schema.private_context_fingerprint_for(ctx)</code></a> should be included in its cache key. In practice, this means that each client can have its own cached responses. Any query that contains a <code class="language-plaintext highlighter-rouge">cacheable(public: false)</code> type or field will use a private cache key.</p>

<p><code class="language-plaintext highlighter-rouge">cacheable(public: true)</code> means that cached values from this type or field may be shared by <em>all</em> clients. Use this for public-facing data which is the same for all viewers. Queries that include <em>only</em> <code class="language-plaintext highlighter-rouge">public: true</code> types and fields will not include <code class="language-plaintext highlighter-rouge">Schema.private_context_fingerprint_for(ctx)</code> in their cache keys. That way their responses will be shared by all clients who request them.</p>

<h2 id="ttl"><code class="language-plaintext highlighter-rouge">ttl:</code></h2>

<p><code class="language-plaintext highlighter-rouge">cacheable(ttl: seconds)</code> expires any cached value after the given number of seconds, regardless of cache fingerprint. <code class="language-plaintext highlighter-rouge">ttl:</code> shines in a few cases:</p>

<ul>
  <li>Objects that can’t reliably generate a fingerprint value (for example, they have no <code class="language-plaintext highlighter-rouge">.updated_at</code> timestamp). In this case, a conservative <code class="language-plaintext highlighter-rouge">ttl</code> may be the only option for cache expiration.</li>
  <li>Or, root-level fields that should be expired after a certain amount of time. The root-level <code class="language-plaintext highlighter-rouge">Query</code> often has <em>no</em> backing object, so it won’t have a cache fingerprint, either. Adding <code class="language-plaintext highlighter-rouge">cacheable: { ttl: ... }</code> to root level fields will provide some caching along with a guarantee about when they’ll be expired.</li>
  <li>Or, list responses that may be difficult to invalidate properly (see below).</li>
</ul>

<p>Under the hood, <code class="language-plaintext highlighter-rouge">ttl:</code> is implemented with Redis’s <code class="language-plaintext highlighter-rouge">EXPIRE</code>.</p>

<h2 id="caching-lists-and-connections">Caching lists and connections</h2>

<p>Lists and connections require a little extra consideration. In order to effectively bust the cache, items that belong to the list of “parent” object should update the parent whenever they’re modified in a way that changes the state of the list. For example, if there’s a list of players on a team:</p>

<div class="language-graphql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="n">team</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">players</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">totalCount</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>None of the <em>specific</em> <code class="language-plaintext highlighter-rouge">Player</code>s will be part of the cached response, but the <code class="language-plaintext highlighter-rouge">Team</code> will be. To properly invalidate the cache, the <code class="language-plaintext highlighter-rouge">Team</code>’s <code class="language-plaintext highlighter-rouge">updated_at</code> (or other cache key) should be updated whenever a <code class="language-plaintext highlighter-rouge">Player</code> is added or removed from the <code class="language-plaintext highlighter-rouge">Team</code>.</p>

<p>If a list may be sorted, then updates to <code class="language-plaintext highlighter-rouge">Player</code>s should also update the <code class="language-plaintext highlighter-rouge">Team</code> so that any sorted results in the cache are invalidated, too. Alternatively (or additionally), you could use a <code class="language-plaintext highlighter-rouge">ttl:</code> to expire cached results after a certain duration, just to be sure that results are eventually expired.</p>

<p>By default, connection-related objects (like <code class="language-plaintext highlighter-rouge">*Connection</code> and <code class="language-plaintext highlighter-rouge">*Edge</code> types) “inherit” cacheability from their node types. You can override this in your base classes as long as <code class="language-plaintext highlighter-rouge">GraphQL::Enterprise::ObjectCache::ObjectIntegration</code> is included in the inheritance chain somewhere.</p>

<h2 id="caching-introspection">Caching Introspection</h2>

<p>By default, introspection fields are considered <em>public</em> for all queries. This means that they are considered cacheable and their results will be reused for any clients who request them. When <a href="/object_cache/schema_setup#add-the-cache">adding the ObjectCache to your schema</a>, you can provide some options to customize this behavior:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">cache_introspection: { public: false, ... }</code> to use <a href="#public"><code class="language-plaintext highlighter-rouge">public: false</code></a> for all introspection fields. Use this if you hide schema members for some clients.</li>
  <li><code class="language-plaintext highlighter-rouge">cache_introspection: false</code> to completely disable caching on introspection fields.</li>
  <li><code class="language-plaintext highlighter-rouge">cache_introspection: { ttl: ..., ... }</code> to set a <a href="#ttl">ttl</a> (in seconds) for introspection fields.</li>
</ul>

<h2 id="object-dependencies">Object Dependencies</h2>

<p>By default, the <code class="language-plaintext highlighter-rouge">object</code> of a GraphQL Object type is used for caching the fields selected on that object. But, you can specify what object (or objects) should be used to check the cache by implementing <code class="language-plaintext highlighter-rouge">def self.cache_dependencies_for(object, context)</code> in your type definition. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Types::Player</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">cache_dependencies_for</span><span class="p">(</span><span class="n">player</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
    <span class="c1"># we update the team's timestamp whenever player details change,</span>
    <span class="c1"># so ignore the `player` for caching purposes</span>
    <span class="n">player</span><span class="p">.</span><span class="nf">team</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Use this to:</p>

<ul>
  <li>improve performance when caching lists of children that belong to a parent object</li>
  <li>register other objects with the ObjectCache when running a query. (<code class="language-plaintext highlighter-rouge">cacheable_object(obj)</code> or <code class="language-plaintext highlighter-rouge">def self.object_fingerprint_for</code> can also be used in this case.)</li>
</ul>

<p>If this method returns an <code class="language-plaintext highlighter-rouge">Array</code>, each object in the array will be registered with the cache.</p>

</div>
<p class="guide-footer">
  Suggestion, improvement, or correction?
  <a href="https://github.com/rmosolgo/graphql-ruby/edit/master/guides/object_cache/caching.md">Edit this file</a> or
  <a href="https://github.com/rmosolgo/graphql-ruby/issues/new?title=Guide: Caching Results">report an issue</a>.
</p>
<script>
  // Find headers with IDs and wrap their text in `<a href=></a>`
  // That way people can easily copy the link.
  var headers = document.querySelectorAll("h1, h2, h3, h4, h5");
  var header, idText, headerLink;
  for (var i = 0; i < headers.length; i++) {
    header = headers[i];
    idText = header.id;
    if (idText) {
      headerLink = document.createElement("a");
      headerLink.href = "#" + idText;
      headerLink.textContent = header.textContent;
      header.textContent = "";
      header.appendChild(headerLink);
    }
  }
  function navigateToSelected(selectElement) {
    var nextPage = selectElement.selectedOptions[0].dataset["target"]
    document.location = nextPage
  }
</script>

    </div>
    <script src="https://cdn.jsdelivr.net/algoliasearch/3/algoliasearchLite.min.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
